{"config":{"indexing":"full","lang":["en"],"min_search_length":2,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Welcome to MV2 dynamic library MV2 is a symmetric cryptographic system designed for cryptographic transformation (encryption) of an arbitrary length plaintext (open message) into a ciphertext consisting of two parts. By setting parameters of the cipher one may control lengths of the parts. This cryptographic system doesn't belong to neither block class ciphers, nor to the stream class ciphers. The first component of the cascade MV2 is a stream cipher. MV2 is an iterative probabilistic cipher, where each iteration resembles a round of a substitution-permutation network when not a single block as in block ciphers, but rather the whole message is being processed. The Substitution-Permutation Network (SPN) is a fundamental architecture of block ciphers, based on concepts of confusion and diffusion. The output data consist of two binary sequences we call core and string of flags or flags. The core is a remainder obtained at the last round. A String of flags is a concatenation of output flags obtained at all transformation rounds. MV2 presents several specific and advantageous characteristics: MV2 can complement and co-exist with well-known and proven encryption technologies; most of the commercially valuable benefits can be achieved without changing existing corporate encryption technologies and policies. MV2 \"one-time\" encryption produces unique, tamperproof ciphertext even when encrypting the same plaintext repeatedly using the same key. MV2 ability to require the presence of 3 or more files to read encrypted messages; this provides substantial flexibility and savings when moving or securing data. To understand where this algorithm can be used, you can look at the book Harmed texts . Release notes User's structure and functions Examples Project content License","title":"Home"},{"location":"index.html#welcome-to-mv2-dynamic-library","text":"MV2 is a symmetric cryptographic system designed for cryptographic transformation (encryption) of an arbitrary length plaintext (open message) into a ciphertext consisting of two parts. By setting parameters of the cipher one may control lengths of the parts. This cryptographic system doesn't belong to neither block class ciphers, nor to the stream class ciphers. The first component of the cascade MV2 is a stream cipher. MV2 is an iterative probabilistic cipher, where each iteration resembles a round of a substitution-permutation network when not a single block as in block ciphers, but rather the whole message is being processed. The Substitution-Permutation Network (SPN) is a fundamental architecture of block ciphers, based on concepts of confusion and diffusion. The output data consist of two binary sequences we call core and string of flags or flags. The core is a remainder obtained at the last round. A String of flags is a concatenation of output flags obtained at all transformation rounds. MV2 presents several specific and advantageous characteristics: MV2 can complement and co-exist with well-known and proven encryption technologies; most of the commercially valuable benefits can be achieved without changing existing corporate encryption technologies and policies. MV2 \"one-time\" encryption produces unique, tamperproof ciphertext even when encrypting the same plaintext repeatedly using the same key. MV2 ability to require the presence of 3 or more files to read encrypted messages; this provides substantial flexibility and savings when moving or securing data. To understand where this algorithm can be used, you can look at the book Harmed texts .","title":"Welcome to MV2 dynamic library"},{"location":"index.html#release-notes","text":"","title":"Release notes"},{"location":"index.html#users-structure-and-functions","text":"","title":"User's structure and functions"},{"location":"index.html#examples","text":"","title":"Examples"},{"location":"index.html#project-content","text":"","title":"Project content"},{"location":"index.html#license","text":"","title":"License"},{"location":"components.html","text":"components.md Project content This implementation contains a Visual Studio solution for creating dynamic libraries (debug and release) for Windows x86/x64 and Linux, and for creating test units for them. It also contains documentation is written as regular Markdown files and compiled using the MkDocs static site generator. Source code of dynamic libraries Folder ./src Contains cpp source code files for dynamic library implementation Folder ./include Contains header files for dynamic library implementation Folder ./mv2dll Contains a Visual Studio project for a Windows dynamic library. Folder ./mv2lib Contains a Visual Studio project for a Linux dynamic library. Source code of test modules Folder ./TestDll Contains a Visual Studio project and source code for testing a Windows dynamic library. Folder ./TestMv2Lin Contains a Visual Studio project and source code for a Linux dynamic library. Documentation Contains documentation.","title":"Project content"},{"location":"components.html#componentsmd","text":"","title":"components.md"},{"location":"components.html#project-content","text":"This implementation contains a Visual Studio solution for creating dynamic libraries (debug and release) for Windows x86/x64 and Linux, and for creating test units for them. It also contains documentation is written as regular Markdown files and compiled using the MkDocs static site generator.","title":"Project content"},{"location":"components.html#source-code-of-dynamic-libraries","text":"","title":"Source code of dynamic libraries"},{"location":"components.html#folder-src","text":"Contains cpp source code files for dynamic library implementation","title":"Folder ./src"},{"location":"components.html#folder-include","text":"Contains header files for dynamic library implementation","title":"Folder ./include"},{"location":"components.html#folder-mv2dll","text":"Contains a Visual Studio project for a Windows dynamic library.","title":"Folder ./mv2dll"},{"location":"components.html#folder-mv2lib","text":"Contains a Visual Studio project for a Linux dynamic library.","title":"Folder ./mv2lib"},{"location":"components.html#source-code-of-test-modules","text":"","title":"Source code of test modules"},{"location":"components.html#folder-testdll","text":"Contains a Visual Studio project and source code for testing a Windows dynamic library.","title":"Folder ./TestDll"},{"location":"components.html#folder-testmv2lin","text":"Contains a Visual Studio project and source code for a Linux dynamic library.","title":"Folder ./TestMv2Lin"},{"location":"components.html#documentation","text":"Contains documentation.","title":"Documentation"},{"location":"examples.html","text":"Examples Linux // ..... #include \"../include/mv2lin.h\" // ... some code ... uint8_t* hKey = (uint8_t*) iKey; // pointer to key buffer // ..... bRes = MV2SetKey(hKey, j); if (!bRes) { std::cout << \"\\r\\nSET KEY\" << j * 8 << \" RETURN ERROR!!!\\r\\n\"; break; } MV2_BUFFER mv2Buf; std::unique_ptr<uint8_t[]> ptrCore(new uint8_t[1024]); std::unique_ptr<uint8_t[]> ptrFlags(new uint8_t[2 * MEGABYTE + MEGABYTE / 512]); std::unique_ptr<uint8_t[]> ptrSRC(new uint8_t[2 * MEGABYTE]); std::unique_ptr<uint8_t[]> ptrMem(new uint8_t[2 * MEGABYTE]); mv2Buf.CoreBuf = ptrCore.get();// (BYTE*) new BYTE[1024]; if (mv2Buf.CoreBuf) mv2Buf.szCoreBuf = 1024; mv2Buf.FlagBuf = ptrFlags.get();// (BYTE*) new BYTE[2 * MEGABYTE + MEGABYTE / 512]; if (mv2Buf.FlagBuf) mv2Buf.szFlagBuf = 2 * MEGABYTE + MEGABYTE / 512; mv2Buf.SrcBuf = ptrSRC.get();// (BYTE*) new BYTE[2 * MEGABYTE]; if (mv2Buf.SrcBuf) { mv2Buf.szSrcBuf = 2 * MEGABYTE; }","title":"Examples"},{"location":"examples.html#examples","text":"","title":"Examples"},{"location":"examples.html#linux","text":"// ..... #include \"../include/mv2lin.h\" // ... some code ... uint8_t* hKey = (uint8_t*) iKey; // pointer to key buffer // ..... bRes = MV2SetKey(hKey, j); if (!bRes) { std::cout << \"\\r\\nSET KEY\" << j * 8 << \" RETURN ERROR!!!\\r\\n\"; break; } MV2_BUFFER mv2Buf; std::unique_ptr<uint8_t[]> ptrCore(new uint8_t[1024]); std::unique_ptr<uint8_t[]> ptrFlags(new uint8_t[2 * MEGABYTE + MEGABYTE / 512]); std::unique_ptr<uint8_t[]> ptrSRC(new uint8_t[2 * MEGABYTE]); std::unique_ptr<uint8_t[]> ptrMem(new uint8_t[2 * MEGABYTE]); mv2Buf.CoreBuf = ptrCore.get();// (BYTE*) new BYTE[1024]; if (mv2Buf.CoreBuf) mv2Buf.szCoreBuf = 1024; mv2Buf.FlagBuf = ptrFlags.get();// (BYTE*) new BYTE[2 * MEGABYTE + MEGABYTE / 512]; if (mv2Buf.FlagBuf) mv2Buf.szFlagBuf = 2 * MEGABYTE + MEGABYTE / 512; mv2Buf.SrcBuf = ptrSRC.get();// (BYTE*) new BYTE[2 * MEGABYTE]; if (mv2Buf.SrcBuf) { mv2Buf.szSrcBuf = 2 * MEGABYTE; }","title":"Linux"},{"location":"license.html","text":"License","title":"License"},{"location":"license.html#license","text":"","title":"License"},{"location":"procedures.html","text":"User's structure and functions To work, you must specify a key and use the encryption or decryption function. A key is an arbitrary sequence of bytes of 16, 32, 64 or 256 bytes in size. This library is multi-threaded. Different threads use different memory objects to manipulate data. When a thread calls MV2SetKey function for the first time, an MV2 object is created to implement the main functions. The MV2Release function is used to free up the memory of an object. When the library is loaded into the calling process's memory, an object is created to implement the basic functionality. Functions MV2SetKey This function creates an MV2 object if it does not exist and sets the encryption/decryption key defined as bool MV2SetKey( unsigned char * srcKey, int szKey ); Parameters: srcKey - [in] Pointer to the buffer containing the key. To be leveled up to the unsigned int size. szKey - [in] Size of the key in bytes. Current options are 16(128bits), 32(256 bits), 64 (512 bits) 128 (1024 bits) or 256 (2048 bits). Return Values If the function succeeds, the return value is TRUE. Remarks This function must be called before encrypting or decrypting data. MV2Encrypt This function encrypts the data and is defined as bool MV2Encrypt( MV2_BUFFER &mv2Buf, long RestLength ); Parameters mv2Buf - [in] \\ [out] Structure containing address and size of buffers for input and output data SrcBuf - [in] - pointer to the data block to be encrypted szSrcBuf - [in] - size of data block to be encrypted in bytes; CoreBuf - [in\\out] - pointer to the memory area in which the core is to be placed; szCoreBuf - [in] - max size of memory area in bytes; [out] - size of the output core in bytes FlagBuf - [in\\out] - pointer to the memory area in which flags are to be placed; szFlagBuf - [in] - max size of memory area in bytes; [out] - size of the output flags in bytes RetCode - [out] - termination code; RestLength - [in] Encryption parameter. Values from 1 to 50 set the number of encryptions that have to be performed. Values more than 50 set max length for the core upon encryption. Return Values If the function succeeds, the return value is TRUE. If RestLength is less than 0, the return value is FALSE. If an error occurs during encryption, the function returns FALSE. Termination code is in the field RetCode of the structure MV2_BUFFER. The encrypted data are located at the addresses from the fields CoreBuf and FalgBuf, the sizes of the encrypted data are located in the fields szCoreBuf and szFalgBuf of the structure MV2_BUFFER. Remarks Before using the function set the encryption key by the function MV2SetKey . The calling process has to allocate memory before using MV2Encrypt. Field SrcBuf of the input structure MV2_BUFFER points at the address of the data that have to be encrypted. Field szSrcBuf contains data size in bytes. Fields CoreBuf and FlagBuf point at the addresses of memory blocks serving for allocation of the output data. MV2Decrypt This function decrypts the data and is defined as bool MV2Decrypt(MV2_BUFFER& mv2Buf); Parameters: mv2Buf - [in] \\ [out] Structure containing addresses and sizes of buffers for the input and output data SrcBuf [out] - address of the buffer in which decrypted data have to be placed to szSrcBuf [out] - max size of the buffer in bytes; CoreBuf [in] - address of the memory area containing the core; szCoreBuf [in] - size of the core in bytes; FlagBuf [in] - address of the memory area containing flags; szFlagBuf [in] - size of flags in bytes; RetCode [out] - termination code; Return Values If the function succeeds, the return value is TRUE. If there is an error during decryption, the function returns FALSE. Termination code is in the field RetCode of the structure MV2_BUFFER. Decrypted data are placed to the memory area with the address from the field SrcBuf, the size is set by the fields szSrcBuf and szFalgBuf of the structure MV2_BUFFER. Remarks Before using the function set the decryption key by the function MV2SetKey. The calling process has to allocate memory before using MV2Decrypt. MV2GetStatus This function returns the current status of the process and is defined as int MV2GetStatus(); Parameters: Return Values Remarks MV2GetStep The function returns the number of performed rounds and is defined as int MV2GetStep(); Parameters: This function has no parameters. Return Values Function returns current status of the encryption\\decryption process or an error code. MV2Release(); The function destroys the MV2 object for the current thread and is defined as void MV2Release(); Parameters: This function has no parameters. Return Values The function does not return any value. MV2CalcRecomendedSizes Helper function for calculating buffer sizes for CORE and FLAGS components. It defines as bool MV2CalcRecomendedSizes( unsigned int cbSource, unsigned int dwStep, unsigned int& cbCore, unsigned int& cbFlags ); Parameters: cbSource - [in] plaintext size dwStep - [in] Number of rounds (if less than 50) or maximum CORE size (otherwise) cbCore - [in] \\ [out] recommended CORE buffer size cbFlags - [in] \\ [out] recommended maximum buffer size for FLAGS Return Values Returns TRUE if successful or FALSE otherwise. The function calculates the maximum buffer sizes and fills in the corresponding fields. Structures and constants MV2_BUFFER This structure contains the addresses and sizes of the input and output data and is defined as follows: typedef struct tagMV2_BUFFER { int szSrcBuf; // plaintext buffer size unsigned char* SrcBuf; // pointer to plaintext buffer int szCoreBuf; // buffer size for CORE data (encryption) or CORE data (decryption) unsigned char* CoreBuf; // pointer to the CORE buffer int szFlagBuf; // buffer size for FLAGS data (encryption) or FLAGS data (decryption) unsigned char* FlagBuf; // pointer to the FLAGS buffer int RetCode; // operation result code }MV2_BUFFER; Defined Constants enum KeySize { sizeZero = 0, size256bits = 32, size512bits = 64, size1024bits = 128, size2048bits = 256, sizeLast }; enum MV2ERROR { MV2ERR_WORK = -1, MV2ERR_DWORK = -2, MV2ERR_OK = 0, MV2ERR_SRCNOTEXIST = 1, MV2ERR_OPEN = 2, MV2ERR_INPUTRND = 22, MV2ERR_MEMALLOC = 40, MV2ERR_DECRYPT = 65, MV2ERR_WRITE = 77, MV2ERR_WRITEFLAG = 79, MV2ERR_CREATEOUT = 80, MV2ERR_KEYNOTSET = 99, MV2ERR_KEYINT = 101, MV2ERR_ENDFLAGS = 103, MV2ERR_ENDCORE = 104, MV2ERR_KEY = 105 };","title":"Structures and functions"},{"location":"procedures.html#users-structure-and-functions","text":"To work, you must specify a key and use the encryption or decryption function. A key is an arbitrary sequence of bytes of 16, 32, 64 or 256 bytes in size. This library is multi-threaded. Different threads use different memory objects to manipulate data. When a thread calls MV2SetKey function for the first time, an MV2 object is created to implement the main functions. The MV2Release function is used to free up the memory of an object. When the library is loaded into the calling process's memory, an object is created to implement the basic functionality.","title":"User's structure and functions"},{"location":"procedures.html#functions","text":"","title":"Functions"},{"location":"procedures.html#mv2setkey","text":"This function creates an MV2 object if it does not exist and sets the encryption/decryption key defined as bool MV2SetKey( unsigned char * srcKey, int szKey ); Parameters: srcKey - [in] Pointer to the buffer containing the key. To be leveled up to the unsigned int size. szKey - [in] Size of the key in bytes. Current options are 16(128bits), 32(256 bits), 64 (512 bits) 128 (1024 bits) or 256 (2048 bits). Return Values If the function succeeds, the return value is TRUE. Remarks This function must be called before encrypting or decrypting data.","title":"MV2SetKey"},{"location":"procedures.html#mv2encrypt","text":"This function encrypts the data and is defined as bool MV2Encrypt( MV2_BUFFER &mv2Buf, long RestLength ); Parameters mv2Buf - [in] \\ [out] Structure containing address and size of buffers for input and output data SrcBuf - [in] - pointer to the data block to be encrypted szSrcBuf - [in] - size of data block to be encrypted in bytes; CoreBuf - [in\\out] - pointer to the memory area in which the core is to be placed; szCoreBuf - [in] - max size of memory area in bytes; [out] - size of the output core in bytes FlagBuf - [in\\out] - pointer to the memory area in which flags are to be placed; szFlagBuf - [in] - max size of memory area in bytes; [out] - size of the output flags in bytes RetCode - [out] - termination code; RestLength - [in] Encryption parameter. Values from 1 to 50 set the number of encryptions that have to be performed. Values more than 50 set max length for the core upon encryption. Return Values If the function succeeds, the return value is TRUE. If RestLength is less than 0, the return value is FALSE. If an error occurs during encryption, the function returns FALSE. Termination code is in the field RetCode of the structure MV2_BUFFER. The encrypted data are located at the addresses from the fields CoreBuf and FalgBuf, the sizes of the encrypted data are located in the fields szCoreBuf and szFalgBuf of the structure MV2_BUFFER. Remarks Before using the function set the encryption key by the function MV2SetKey . The calling process has to allocate memory before using MV2Encrypt. Field SrcBuf of the input structure MV2_BUFFER points at the address of the data that have to be encrypted. Field szSrcBuf contains data size in bytes. Fields CoreBuf and FlagBuf point at the addresses of memory blocks serving for allocation of the output data.","title":"MV2Encrypt"},{"location":"procedures.html#mv2decrypt","text":"This function decrypts the data and is defined as bool MV2Decrypt(MV2_BUFFER& mv2Buf); Parameters: mv2Buf - [in] \\ [out] Structure containing addresses and sizes of buffers for the input and output data SrcBuf [out] - address of the buffer in which decrypted data have to be placed to szSrcBuf [out] - max size of the buffer in bytes; CoreBuf [in] - address of the memory area containing the core; szCoreBuf [in] - size of the core in bytes; FlagBuf [in] - address of the memory area containing flags; szFlagBuf [in] - size of flags in bytes; RetCode [out] - termination code; Return Values If the function succeeds, the return value is TRUE. If there is an error during decryption, the function returns FALSE. Termination code is in the field RetCode of the structure MV2_BUFFER. Decrypted data are placed to the memory area with the address from the field SrcBuf, the size is set by the fields szSrcBuf and szFalgBuf of the structure MV2_BUFFER. Remarks Before using the function set the decryption key by the function MV2SetKey. The calling process has to allocate memory before using MV2Decrypt.","title":"MV2Decrypt"},{"location":"procedures.html#mv2getstatus","text":"This function returns the current status of the process and is defined as int MV2GetStatus(); Parameters: Return Values Remarks","title":"MV2GetStatus"},{"location":"procedures.html#mv2getstep","text":"The function returns the number of performed rounds and is defined as int MV2GetStep(); Parameters: This function has no parameters. Return Values Function returns current status of the encryption\\decryption process or an error code.","title":"MV2GetStep"},{"location":"procedures.html#mv2release","text":"The function destroys the MV2 object for the current thread and is defined as void MV2Release(); Parameters: This function has no parameters. Return Values The function does not return any value.","title":"MV2Release();"},{"location":"procedures.html#mv2calcrecomendedsizes","text":"Helper function for calculating buffer sizes for CORE and FLAGS components. It defines as bool MV2CalcRecomendedSizes( unsigned int cbSource, unsigned int dwStep, unsigned int& cbCore, unsigned int& cbFlags ); Parameters: cbSource - [in] plaintext size dwStep - [in] Number of rounds (if less than 50) or maximum CORE size (otherwise) cbCore - [in] \\ [out] recommended CORE buffer size cbFlags - [in] \\ [out] recommended maximum buffer size for FLAGS Return Values Returns TRUE if successful or FALSE otherwise. The function calculates the maximum buffer sizes and fills in the corresponding fields.","title":"MV2CalcRecomendedSizes"},{"location":"procedures.html#structures-and-constants","text":"","title":"Structures and constants"},{"location":"procedures.html#mv2_buffer","text":"This structure contains the addresses and sizes of the input and output data and is defined as follows: typedef struct tagMV2_BUFFER { int szSrcBuf; // plaintext buffer size unsigned char* SrcBuf; // pointer to plaintext buffer int szCoreBuf; // buffer size for CORE data (encryption) or CORE data (decryption) unsigned char* CoreBuf; // pointer to the CORE buffer int szFlagBuf; // buffer size for FLAGS data (encryption) or FLAGS data (decryption) unsigned char* FlagBuf; // pointer to the FLAGS buffer int RetCode; // operation result code }MV2_BUFFER;","title":"MV2_BUFFER"},{"location":"procedures.html#defined-constants","text":"enum KeySize { sizeZero = 0, size256bits = 32, size512bits = 64, size1024bits = 128, size2048bits = 256, sizeLast }; enum MV2ERROR { MV2ERR_WORK = -1, MV2ERR_DWORK = -2, MV2ERR_OK = 0, MV2ERR_SRCNOTEXIST = 1, MV2ERR_OPEN = 2, MV2ERR_INPUTRND = 22, MV2ERR_MEMALLOC = 40, MV2ERR_DECRYPT = 65, MV2ERR_WRITE = 77, MV2ERR_WRITEFLAG = 79, MV2ERR_CREATEOUT = 80, MV2ERR_KEYNOTSET = 99, MV2ERR_KEYINT = 101, MV2ERR_ENDFLAGS = 103, MV2ERR_ENDCORE = 104, MV2ERR_KEY = 105 };","title":"Defined Constants"},{"location":"release-notes.html","text":"release-notes.md MV2 is a symmetric cryptographic system designed for cryptographic transformation (encryption) of an arbitrary length plaintext (open message) into a ciphertext consisting of two parts. By setting parameters of the cipher one may control lengths of the parts. This cryptographic system doesn't belong to neither block class ciphers, nor to the stream class ciphers. The first component of the cascade MV2 is a stream cipher. MV2 is an iterative probabilistic cipher, where each iteration resembles a round of a substitution-permutation network when not a single block as in block ciphers, but rather the whole message is being processed. The Substitution-Permutation Network (SPN) is a fundamental architecture of block ciphers, based on concepts of confusion and diffusion. The output data consist of two binary sequences we call core and string of flags or flags. The core is a remainder obtained at the last round. A String of flags is a concatenation of output flags obtained at all transformation rounds. To understand where this algorithm can be used, you can look at the book Harmed texts . This project contains source files for implementing dynamic libraries for Linux and Windows(C) for x86/x64 processors. It also contains documentation and test modules for testing and demonstrating the use of the libraries. The documentation is written as regular Markdown files and compiled using the MkDocs static site generator. All trademarks are the property of their respective owners.","title":"Release Notes"},{"location":"release-notes.html#release-notesmd","text":"MV2 is a symmetric cryptographic system designed for cryptographic transformation (encryption) of an arbitrary length plaintext (open message) into a ciphertext consisting of two parts. By setting parameters of the cipher one may control lengths of the parts. This cryptographic system doesn't belong to neither block class ciphers, nor to the stream class ciphers. The first component of the cascade MV2 is a stream cipher. MV2 is an iterative probabilistic cipher, where each iteration resembles a round of a substitution-permutation network when not a single block as in block ciphers, but rather the whole message is being processed. The Substitution-Permutation Network (SPN) is a fundamental architecture of block ciphers, based on concepts of confusion and diffusion. The output data consist of two binary sequences we call core and string of flags or flags. The core is a remainder obtained at the last round. A String of flags is a concatenation of output flags obtained at all transformation rounds. To understand where this algorithm can be used, you can look at the book Harmed texts . This project contains source files for implementing dynamic libraries for Linux and Windows(C) for x86/x64 processors. It also contains documentation and test modules for testing and demonstrating the use of the libraries. The documentation is written as regular Markdown files and compiled using the MkDocs static site generator. All trademarks are the property of their respective owners.","title":"release-notes.md"}]}